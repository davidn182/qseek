{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Qseek \ud83d\udd25","text":"<p>Qseek is an earthquake detection and localisation framework. It combines modern machine learning phase detection and robust migration and stacking techniques.</p> <p>The detector is leveraging Pyrocko and SeisBench, it is highly-performant and can search massive data sets for seismic activity efficiently.</p> <p>Citation</p> <p>Marius Paul Isken, Peter Niemz, Jannes M\u00fcnchmeyer, Sebastian Heimann, Simone Cesca, Torsten Dahm, Qseek: A data-driven Framework for Machine-Learning Earthquake Detection, Localization and Characterization, Seismica, 2024, submitted</p> <p></p> <p>Seismic swarm activity at Iceland, Reykjanes Peninsula during a 2020 unrest. 15,000+ earthquakes detected, outlining a dike intrusion, preceeding the 2021 Fagradasfjall eruption. Visualized in Pyrocko Sparrow.</p>"},{"location":"#features","title":"Features","text":"<ul> <li> Earthquake phase detection using machine-learning pickers from SeisBench<ul> <li> PhaseNet (Zhu and Beroza, 2018</li> <li> EQTransformer (Mousavi et al., 2020)</li> <li> OBSTransformer (Niksejel and Zahng, 2024)</li> <li> LFEDetect</li> </ul> </li> <li> Octree localisation approach for efficient and accurate search</li> <li> Different velocity models:<ul> <li> Constant velocity</li> <li> 1D Layered velocity model</li> <li> 3D fast-marching velocity model (NonLinLoc compatible)</li> </ul> </li> <li> Extraction of earthquake event features:<ul> <li> Local magnitudes</li> <li> Ground motion attributes</li> </ul> </li> <li> Automatic extraction of modelled and picked travel times</li> <li> Calculation and application of station corrections / station delay times</li> <li> Real-time analytics on streaming data (e.g. SeedLink)</li> </ul> <p>Get Started!</p>"},{"location":"#build-with","title":"Build with","text":""},{"location":"benchmark/","title":"Benchmark","text":""},{"location":"benchmark/#computation-performance","title":"Computation Performance","text":"<p>Qseek is built for searching in large-N data sets. The implementation is leveraging Python <code>asyncio</code> heavily to implement threading and keeping the CPU busy. It is built on top of highly performant Pyrocko functions implemented in C language. The inference is using PyTorch which enables GPU computation of the seismic imaging functions.</p> <p>This enables high throughput of seismic data in different scenarios.</p> Number Stations Throughput in MB Throughput in Waveform data 300+ 50 MB/sec 12 hours/sec 50 200 MB/sec 6 hours/sec <p>Scanning a 600 GB (~700 years of waveforms) data set costs ~2 days on a 64 cores machine equipped with an Nvidia A100 GPU.</p> <p>Note</p> <p>The performance depends heavily on the octree resolution and the number of events detected in the data set.</p>"},{"location":"benchmark/#related-projects","title":"Related Projects","text":"<p>A list of other projects using stacking and migration approach to back-project seismic energy sources in 3D space:</p>"},{"location":"benchmark/#lassie-v1","title":"Lassie-v1","text":"<p>Lassie - The friendly Earthquake detector in version 1. Qseek utilizes the same optimized heavy-duty functions for stacking and migration as Lassie v1.</p> <p>Lassie-v1 on Pyrocko Git</p>"},{"location":"benchmark/#quakemigrate","title":"QuakeMigrate","text":"<p>QuakeMigrate uses a waveform migration and stacking algorithm to search for coherent seismic phase arrivals across a network of instruments. It produces\u2014from raw data\u2014catalogues of earthquakes with locations, origin times, phase arrival picks, and local magnitude estimates, as well as rigorous estimates of the associated uncertainties.</p> <p>QuakeMigrate on GitHub</p>"},{"location":"benchmark/#bpmf","title":"BPMF","text":"<p>Complete framework for earthquake detection and location: Backprojection and matched-filtering (BPMF), with methods for automatic picking, relocation and efficient waveform stacking.</p> <p>BPMF on GitHub</p>"},{"location":"benchmark/#loki","title":"Loki","text":"<p>LOKI (LOcation of seismic events through traveltime staKIng) is a code that performs earthquake detection and location using waveform coherence analysis (waveform stacking).</p> <p>Loki on GitHub</p>"},{"location":"benchmark/#malmi","title":"MALMI","text":"<p>MALMI (MAchine Learning aided earthquake MIgration location), variant of Loki for detecting and locating earthquakes using ML image functions provided by SeisBench.</p> <p>MALMI on GitHub</p>"},{"location":"getting_started/","title":"Getting Started","text":""},{"location":"getting_started/#installation","title":"Installation","text":"<p>The installation is straight-forward using pip or pipx.</p> From GitHub<pre><code>pip install git+https://github.com/pyrocko/qseek\n</code></pre> <p>or</p> Using pipx<pre><code>pipx install git+https://github.com/pyrocko/qseek\n</code></pre>"},{"location":"getting_started/#running-qseek","title":"Running Qseek","text":"<p>The main entry point in the executeable is the <code>qseek</code> command. The provided command line interface (CLI) and a JSON config file is all what is needed to run the program.</p> <pre><code>qseek --help\n</code></pre> <pre><code>usage: qseek [-h] [--verbose] [--version]\n             {config,search,continue,snuffler,feature-extraction,modules,serve,export,clear-cache,dump-schemas}\n             ...\n\nqseek - The wholesome earthquake detector \ud83d\ude80\n\noptions:\n  -h, --help            show this help message and exit\n  --verbose, -v         increase verbosity of the log messages, repeat to\n                        increase. Default level is INFO\n  --version             show version and exit\n\ncommands:\n  Available commands to run qseek. Get command help with `qseek &lt;command&gt;\n  --help`.\n\n  {config,search,continue,snuffler,feature-extraction,modules,serve,export,clear-cache,dump-schemas}\n    config              print a new config\n    search              start a search\n    continue            continue an existing search\n    snuffler            start the Pyrocko snuffler to inspect waveforms,\n                        events and picks\n    feature-extraction  extract features from an existing run\n    modules             show available modules\n    serve               start webserver and serve results from an existing run\n    export              export detections to different output formats\n    clear-cache         clear the cach directory\n    dump-schemas        dump data models to json-schema (development)\n</code></pre>"},{"location":"getting_started/#initializing-a-new-project","title":"Initializing a New Project","text":"<p>Once installed you can run the <code>qseek</code> executeable to initialize a new project.</p> Initialize new Project<pre><code>qseek config &gt; my-search.json\n</code></pre> <p>Check out the <code>my-search.json</code> config file and add your waveform data and velocity models.</p> Minimal Configuration Example <p>Here is a minimal JSON configuration for Qseek. <pre><code>{\n  \"project_dir\": \".\",\n  \"stations\": {\n    \"pyrocko_station_yamls\": [],\n    \"station_xmls\": [],\n    \"blacklist\": [],\n    \"stations\": []\n  },\n  \"data_provider\": {\n    \"provider\": \"PyrockoSquirrel\",\n    \"environment\": null,\n    \"persistent\": null,\n    \"waveform_dirs\": [],\n    \"start_time\": null,\n    \"end_time\": null,\n    \"channel_selector\": null,\n    \"n_threads\": 8\n  },\n  \"pre_processing\": [\n    {\n      \"process\": \"downsample\",\n      \"stations\": [],\n      \"sampling_frequency\": 100.0\n    },\n    {\n      \"process\": \"bandpass\",\n      \"stations\": [],\n      \"corners\": 4,\n      \"bandpass\": [\n        0.5,\n        30.0\n      ],\n      \"demean\": true\n    }\n  ],\n  \"octree\": {\n    \"location\": {\n      \"lat\": 0.0,\n      \"lon\": 0.0,\n      \"east_shift\": 0.0,\n      \"north_shift\": 0.0,\n      \"elevation\": 0.0,\n      \"depth\": 0.0\n    },\n    \"root_node_size\": 1000.0,\n    \"n_levels\": 5,\n    \"east_bounds\": [\n      -10000.0,\n      10000.0\n    ],\n    \"north_bounds\": [\n      -10000.0,\n      10000.0\n    ],\n    \"depth_bounds\": [\n      0.0,\n      20000.0\n    ]\n  },\n  \"image_functions\": [\n    {\n      \"image\": \"SeisBench\",\n      \"model\": \"PhaseNet\",\n      \"pretrained\": \"original\",\n      \"window_overlap_samples\": 1500,\n      \"torch_use_cuda\": true,\n      \"torch_cpu_threads\": 4,\n      \"batch_size\": 128,\n      \"stack_method\": \"avg\",\n      \"rescale_input\": 1.0,\n      \"phase_map\": {\n        \"P\": \"constant:P\",\n        \"S\": \"constant:S\"\n      },\n      \"weights\": {\n        \"P\": 1.0,\n        \"S\": 1.0\n      }\n    }\n  ],\n  \"ray_tracers\": [\n    {\n      \"tracer\": \"FastMarchingRayTracer\",\n      \"phase\": \"fm:P\",\n      \"interpolation_method\": \"cubic\",\n      \"nthreads\": 0,\n      \"lut_cache_size\": 2147483648,\n      \"velocity_model\": {\n        \"model\": \"Constant3DVelocityModel\",\n        \"grid_spacing\": \"octree\",\n        \"velocity\": 5000.0\n      },\n      \"implementation\": \"scikit-fmm\"\n    },\n    {\n      \"tracer\": \"CakeTracer\",\n      \"phases\": {\n        \"cake:P\": {\n          \"definition\": \"P,p\"\n        },\n        \"cake:S\": {\n          \"definition\": \"S,s\"\n        }\n      },\n      \"earthmodel\": {\n        \"filename\": \"/home/marius/.cache/qseek/velocity_models/default.nd\",\n        \"format\": \"nd\",\n        \"crust2_profile\": \"\",\n        \"raw_file_data\": \"\\n-1.00    5.50    3.59    2.7\\n 0.00    5.50    3.59    2.7\\n 1.00    5.50    3.59    2.7\\n 1.00    6.00    3.92    2.7\\n 4.00    6.00    3.92    2.7\\n 4.00    6.20    4.05    2.7\\n 8.00    6.20    4.05    2.7\\n 8.00    6.30    4.12    2.7\\n13.00    6.30    4.12    2.7\\n13.00    6.40    4.18    2.7\\n17.00    6.40    4.18    2.7\\n17.00    6.50    4.25    2.7\\n22.00    6.50    4.25    2.7\\n22.00    6.60    4.31    2.7\\n26.00    6.60    4.31    2.7\\n26.00    6.80    4.44    2.7\\n30.00    6.80    4.44    2.7\\n30.00    8.10    5.29    2.7\\n45.00    8.10    5.29    2.7\\n\"\n      },\n      \"trim_earth_model_depth\": true,\n      \"lut_cache_size\": 2147483648\n    },\n    {\n      \"tracer\": \"ConstantVelocityTracer\",\n      \"phase\": \"constant:P\",\n      \"velocity\": 5000.0\n    }\n  ],\n  \"distance_weights\": {\n    \"exponent\": 3.0,\n    \"radius_meters\": 8000.0,\n    \"waterlevel\": 0.0,\n    \"lut_cache_size\": 209715200\n  },\n  \"station_corrections\": null,\n  \"magnitudes\": [],\n  \"features\": [],\n  \"semblance_sampling_rate\": 100,\n  \"detection_threshold\": 0.05,\n  \"absorbing_boundary\": false,\n  \"absorbing_boundary_width\": \"root_node_size\",\n  \"node_peak_interpolation\": true,\n  \"detection_blinding\": \"PT2S\",\n  \"power_mean\": 1.0,\n  \"window_length\": \"PT300S\",\n  \"n_threads_parstack\": 0,\n  \"n_threads_argmax\": 16,\n  \"plot_octree_surface\": false,\n  \"created\": \"2024-07-17T15:57:43.833149Z\"\n}\n</code></pre></p> <p>For more details and information about the component, head over to details of the modules.</p>"},{"location":"getting_started/#starting-the-search","title":"Starting the Search","text":"<p>Once happy with the configuration, start the <code>qseek</code> CLI.</p> Start the earthquake detection and localization<pre><code>qseek search my-search.json\n</code></pre>"},{"location":"visualizing_results/","title":"Visualizing Detections","text":"<p>The event detections are exported in Qseek-native JSON, Pyrocko YAML format and as CSV files.</p>"},{"location":"visualizing_results/#pyrocko-sparrow","title":"Pyrocko Sparrow","text":"<p>For large data sets use the Pyrocko Sparrow to visualise seismic event detections in 3D. Also seismic stations and many other features from the Pyrocko ecosystem can be integrated into the view.</p> <p></p>"},{"location":"visualizing_results/#qgis","title":"QGIS","text":"<p>QGIS can be used to import <code>.csv</code> and explore the data in an interactive fashion. Detections can be rendered by e.g. the detection semblance or the calculated magnitude.</p> <p></p>"},{"location":"components/configuration/","title":"Qseek Configuration","text":"<p>At center is a JSON configuration file which is parsed by Pydantic. The following pages will detail how to setup this JSON file for the search.</p> <p>Also see the getting started guide for a brief introduction into the CLI.</p> <p>General configuration conventions are outlines in this guide as well.</p> <p>Create a fresh config file.</p> Using the CLI<pre><code>qseek config\n</code></pre>"},{"location":"components/configuration/#the-search","title":"The Search","text":"<p>The search configuration. This is the entrypoint for the EQ detection and localisation. More information on the submodules (e.g. Octree, Data Provider and other) can be found on subpages in the navigation.</p> <p></p>"},{"location":"components/configuration/#exec-3--search-module","title":"Search Module","text":"Config SearchJSON  <code>stations</code> <p>Station inventory from StationXML or Pyrocko Station YAML.</p> <code>data_provider</code> <p>Data provider for waveform data.</p> <code>pre_processing</code> <p>Pre-processing steps for waveform data.</p> <code>octree</code> <p>Octree volume for the search.</p> <code>image_functions</code> <p>Image functions for waveform processing and phase on-set detection.</p> <code>ray_tracers</code> <p>List of ray tracers for travel time calculation.</p> <code>distance_weights</code> <p>Spatial weights for distance weighting.</p> <code>station_corrections</code> <p>Apply station corrections extracted from a previous run.</p> <code>magnitudes</code> <p>Magnitude calculators to use.</p> <code>features</code> <p>Event features to extract.</p> <code>semblance_sampling_rate</code>: <code>10 | 20 | 25 | 50 | 100 | 200 | 400</code> <p>Sampling rate for the semblance image function. Choose from <code>10, 20, 25, 50, 100, 200 or 400</code> Hz.</p> <code>detection_threshold</code>: <code>0.05</code> <p>Detection threshold for semblance.</p> <code>absorbing_boundary</code>: <code>False | with_surface | without_surface</code> <p>Ignore events that are inside the first root node layer of the octree. If <code>with_surface</code>, all events inside the boundaries of the volume are absorbed. If <code>without_surface</code>, events at the surface are not absorbed.</p> <code>absorbing_boundary_width</code> <p>Width of the absorbing boundary around the octree volume. If 'octree' the width is set to the root node size of the octree.</p> <code>node_peak_interpolation</code>: <code>True</code> <p>Interpolate intranode locations for detected events using radial basis functions. If <code>False</code>, the node center location is used for the event hypocentre.</p> <code>detection_blinding</code> <p>Blinding time in seconds before and after the detection peak. This is used to avoid detecting the same event multiple times. Default is 2 seconds.</p> <code>power_mean</code>: <code>1.0</code> <p>Power mean exponent for stacking and combining the image functions for stacking. A value of 1.0 is the arithmetic mean, 2.0 is the quadratic mean. A higher value will result in sharper detections and low values smooth the stacking function.</p> <code>window_length</code> <p>Window length for processing. Smaller window size will be less RAM consuming. Default is 5 minutes.</p> <code>n_threads_parstack</code>: <code>0</code> <p>Number of threads for stacking and migration. <code>0</code> uses all available cores.</p> <code>n_threads_argmax</code>: <code>16</code> <p>Number of threads for argmax. Don't use all core for this operation. Default is <code>16</code>.</p> JSON for Search<pre><code>{\n  \"project_dir\": \".\",\n  \"stations\": {\n    \"pyrocko_station_yamls\": [],\n    \"station_xmls\": [],\n    \"blacklist\": [],\n    \"stations\": []\n  },\n  \"data_provider\": {\n    \"provider\": \"PyrockoSquirrel\",\n    \"environment\": null,\n    \"persistent\": null,\n    \"waveform_dirs\": [],\n    \"start_time\": null,\n    \"end_time\": null,\n    \"channel_selector\": null,\n    \"n_threads\": 8\n  },\n  \"pre_processing\": [\n    {\n      \"process\": \"downsample\",\n      \"stations\": [],\n      \"sampling_frequency\": 100.0\n    },\n    {\n      \"process\": \"bandpass\",\n      \"stations\": [],\n      \"corners\": 4,\n      \"bandpass\": [\n        0.5,\n        30.0\n      ],\n      \"demean\": true\n    }\n  ],\n  \"octree\": {\n    \"location\": {\n      \"lat\": 0.0,\n      \"lon\": 0.0,\n      \"east_shift\": 0.0,\n      \"north_shift\": 0.0,\n      \"elevation\": 0.0,\n      \"depth\": 0.0\n    },\n    \"root_node_size\": 1000.0,\n    \"n_levels\": 5,\n    \"east_bounds\": [\n      -10000.0,\n      10000.0\n    ],\n    \"north_bounds\": [\n      -10000.0,\n      10000.0\n    ],\n    \"depth_bounds\": [\n      0.0,\n      20000.0\n    ]\n  },\n  \"image_functions\": [\n    {\n      \"image\": \"SeisBench\",\n      \"model\": \"PhaseNet\",\n      \"pretrained\": \"original\",\n      \"window_overlap_samples\": 1500,\n      \"torch_use_cuda\": true,\n      \"torch_cpu_threads\": 4,\n      \"batch_size\": 128,\n      \"stack_method\": \"avg\",\n      \"rescale_input\": 1.0,\n      \"phase_map\": {\n        \"P\": \"constant:P\",\n        \"S\": \"constant:S\"\n      },\n      \"weights\": {\n        \"P\": 1.0,\n        \"S\": 1.0\n      }\n    }\n  ],\n  \"ray_tracers\": [\n    {\n      \"tracer\": \"CakeTracer\",\n      \"phases\": {\n        \"cake:P\": {\n          \"definition\": \"P,p\"\n        },\n        \"cake:S\": {\n          \"definition\": \"S,s\"\n        }\n      },\n      \"earthmodel\": {\n        \"filename\": \"/home/marius/.cache/qseek/velocity_models/default.nd\",\n        \"format\": \"nd\",\n        \"crust2_profile\": \"\",\n        \"raw_file_data\": \"\\n-1.00    5.50    3.59    2.7\\n 0.00    5.50    3.59    2.7\\n 1.00    5.50    3.59    2.7\\n 1.00    6.00    3.92    2.7\\n 4.00    6.00    3.92    2.7\\n 4.00    6.20    4.05    2.7\\n 8.00    6.20    4.05    2.7\\n 8.00    6.30    4.12    2.7\\n13.00    6.30    4.12    2.7\\n13.00    6.40    4.18    2.7\\n17.00    6.40    4.18    2.7\\n17.00    6.50    4.25    2.7\\n22.00    6.50    4.25    2.7\\n22.00    6.60    4.31    2.7\\n26.00    6.60    4.31    2.7\\n26.00    6.80    4.44    2.7\\n30.00    6.80    4.44    2.7\\n30.00    8.10    5.29    2.7\\n45.00    8.10    5.29    2.7\\n\"\n      },\n      \"trim_earth_model_depth\": true,\n      \"lut_cache_size\": 2147483648\n    },\n    {\n      \"tracer\": \"ConstantVelocityTracer\",\n      \"phase\": \"constant:P\",\n      \"velocity\": 5000.0\n    }\n  ],\n  \"distance_weights\": {\n    \"exponent\": 3.0,\n    \"radius_meters\": 8000.0,\n    \"waterlevel\": 0.0,\n    \"lut_cache_size\": 209715200\n  },\n  \"station_corrections\": null,\n  \"magnitudes\": [],\n  \"features\": [],\n  \"semblance_sampling_rate\": 100,\n  \"detection_threshold\": 0.05,\n  \"absorbing_boundary\": false,\n  \"absorbing_boundary_width\": \"root_node_size\",\n  \"node_peak_interpolation\": true,\n  \"detection_blinding\": \"PT2S\",\n  \"power_mean\": 1.0,\n  \"window_length\": \"PT300S\",\n  \"n_threads_parstack\": 0,\n  \"n_threads_argmax\": 16,\n  \"plot_octree_surface\": false,\n  \"created\": \"2024-07-17T15:57:45.888347Z\"\n}\n</code></pre>"},{"location":"components/configuration/#minimal-config","title":"Minimal Config","text":"<p>This is a minimal config which can used to start a Qseek search.</p> Minimal Qseek Config<pre><code>{\n  \"project_dir\": \".\",\n  \"stations\": {\n    \"station_xmls\": [],\n    \"pyrocko_station_yamls\": [\"search/pyrocko-stations.yaml\"],\n  },\n  \"data_provider\": {\n    \"provider\": \"PyrockoSquirrel\",\n    \"environment\": \".\",\n    \"waveform_dirs\": [\"data/\"],\n  },\n  \"octree\": {\n    \"location\": {\n      \"lat\": 0.0,\n      \"lon\": 0.0,\n      \"east_shift\": 0.0,\n      \"north_shift\": 0.0,\n      \"elevation\": 0.0,\n      \"depth\": 0.0\n    },\n    \"root_node_size\": 2000.0,\n    \"n_levels\": 3,\n    \"east_bounds\": [\n      -10000.0,\n      10000.0\n    ],\n    \"north_bounds\": [\n      -10000.0,\n      10000.0\n    ],\n    \"depth_bounds\": [\n      0.0,\n      20000.0\n    ],\n    \"absorbing_boundary\": 1000.0\n  },\n  \"image_functions\": [\n    {\n      \"image\": \"PhaseNet\",\n      \"model\": \"ethz\",\n      \"torch_use_cuda\": false,\n      \"phase_map\": {\n        \"P\": \"constant:P\",\n        \"S\": \"constant:S\"\n      },\n    }\n  ],\n  \"ray_tracers\": [\n    {\n    \"tracer\": \"ConstantVelocityTracer\",\n    \"phase\": \"constant:P\",\n    \"velocity\": 5000.0\n    }\n  ],\n  \"station_corrections\": {},\n  \"event_features\": [],\n  \"sampling_rate\": 100,\n  \"detection_threshold\": 0.05,\n  \"detection_blinding\": \"PT2S\",\n  \"node_split_threshold\": 0.9,\n  \"window_length\": \"PT300S\",\n  \"n_threads_parstack\": 0,\n  \"n_threads_argmax\": 4,\n}\n</code></pre>"},{"location":"components/configuration/#structure","title":"Structure","text":"<p>Structure of the search and optimisation of the octree, which is focusing in on seismic energy.</p> <pre><code>%%{init: {'theme': 'neutral', 'themeVariables': { 'fontSize': '14pt'}}}%%\nflowchart LR\n    subgraph Seismic Data\n        waveforms([\"fa:fa-water Seismic\\nWaveforms\"])\n        image{{\"fa:fa-bolt Waveform Image Function\\nPhaseNet / EQTransformer / ...\"}}\n        waveforms --&gt; image\n    end\n    subgraph Travel Time Model\n        travelTimes([\"fa:fa-layer-group Seismic\\nTravel Time Model\"])\n        stationCorrections{{\"fab:fa-arrows-to-dot Station Corrections\\nSST / SSST\"}}\n        travelTimes --&gt;|add| stationCorrections\n    end\n    subgraph Stacking and Migration\n        octree[\"fa:fa-cubes\\nOctree Grid\"]\n        detection[\"fa:fa-bullseye Detection\\nand Localisation\"]\n    end\n    featureExtraction(\"fa:fa-info Extract Event Features\\nMagnitudes, Ground Motion, ...\")\n    correctionExtraction(\"fa:fa-stopwatch Extract\\nStation Corrections\")\n\n    image --&gt; octree\n    stationCorrections --&gt; octree\n    detection -.-&gt;|\"fa:fa-cube\\nRefine\"| octree\n    octree --&gt; detection\n    detection --&gt; featureExtraction &amp; correctionExtraction\n</code></pre> <p>Building blocks of the specific stacking and migration method for earthquake detection, localisation and characterisation.</p>"},{"location":"components/general/","title":"General Settings","text":""},{"location":"components/general/#paths","title":"Paths","text":"<p>Paths can be relative to the location of the config file or absolute. File paths and directory paths are checked whether they exist.</p>"},{"location":"components/general/#date-and-time","title":"Date and Time","text":"<p>Serialisation of time, dates and date times and durations follow ISO8601 format with timezone information. E.g. <code>2023-10-28T01:21:21.003Z</code>.</p> <p>Duration are serialized like <code>PT600S</code>, this example shows a duration of 600 seconds, 10 minutes.</p> <p>!!!+ note Timezone Info     All datetimes are timezone aware! For UTC this is the <code>Z</code> or <code>+00:00</code> suffix.     Also other offsets can be defined according to ISO8601.</p> Example of datetimes and durations<pre><code>{\n    \"start_time\": \"2023-10-28T01:21:21.003+00:00\",\n    \"end_time\": \"2023-10-28T01:21:21.003+00:00\",\n    \"duration\": \"PT600S\"\n}\n</code></pre>"},{"location":"components/general/#locations","title":"Locations","text":"<p>Geographic locations have a geographic reference and a relative shift in meters. The octree or velocity models are referenced using Location objects.</p> <p>All distances, depths and elevations are given in meters.</p> <p></p>"},{"location":"components/general/#exec-4--location-module","title":"Location Module","text":"Config LocationJSON  <code>lat</code>: <code>PydanticUndefined</code> <p>Latitude in degrees.</p> <code>lon</code>: <code>PydanticUndefined</code> <p>Longitude in degrees.</p> <code>east_shift</code>: <code>0.0</code> <p>East shift towards geographical reference in meters.</p> <code>north_shift</code>: <code>0.0</code> <p>North shift towards geographical reference in meters.</p> <code>elevation</code>: <code>0.0</code> <p>Elevation in meters.</p> <code>depth</code>: <code>0.0</code> <p>Depth in meters, positive is down.</p> JSON for Location<pre><code>{\n  \"lat\": 52.3825,\n  \"lon\": 13.0644,\n  \"east_shift\": 0.0,\n  \"north_shift\": 0.0,\n  \"elevation\": 0.0,\n  \"depth\": 0.0\n}\n</code></pre>"},{"location":"components/image_function/","title":"Image Function","text":"<p>For image functions this version of Qseek relies heavily on machine learning pickers delivered by SeisBench.</p>"},{"location":"components/image_function/#seisbench-image-function","title":"SeisBench Image Function","text":"<p>SeisBench offers access to a variety of machine learning phase pickers pre-trained on various data sets.</p> <p>Citation PhaseNet</p> <p>Zhu, Weiqiang, and Gregory C. Beroza. \"PhaseNet: A Deep-Neural-Network-Based Seismic Arrival Time Picking Method.\" arXiv preprint arXiv:1803.03211 (2018).</p> <p></p>"},{"location":"components/image_function/#exec-5--seisbench-module","title":"SeisBench Module","text":"<p>PhaseNet image function. For more details see SeisBench documentation.</p> Config SeisBenchJSON  <code>model</code>: <code>PhaseNet | EQTransformer | OBSTransformer | LFEDetect</code> <p>The model to use for the image function. Currently supported models are <code>PhaseNet</code>, <code>EQTransformer</code>, <code>GPD</code>, <code>OBSTransformer</code>, <code>LFEDetect</code>.</p> <code>pretrained</code>: <code>cascadia | cms | diting | dummy | ethz | geofon | instance | iquique | jcms | jcs | jms | lendb | mexico | nankai | neic | obs | obst2024 | original | original_nonconservative | san_andreas | scedc | stead | volpick</code> <p>SeisBench pre-trained model to use. Choose from <code>ethz</code>, <code>geofon</code>, <code>instance</code>, <code>iquique</code>, <code>lendb</code>, <code>neic</code>, <code>obs</code>, <code>original</code>, <code>scedc</code>, <code>stead</code>. For more details see SeisBench documentation</p> <code>window_overlap_samples</code>: <code>1500</code> <p>Window overlap in samples.</p> <code>torch_use_cuda</code> <p>Use CUDA for inference. If <code>True</code> use default device, if <code>int</code> use the specified device.</p> <code>torch_cpu_threads</code>: <code>4</code> <p>Number of CPU threads to use if only CPU is used.</p> <code>batch_size</code>: <code>128</code> <p>Batch size for inference, larger values can improve performance.</p> <code>stack_method</code>: <code>avg | max</code> <p>Method to stack the overlaping blocks internally. Choose from <code>avg</code> and <code>max</code>.</p> <code>rescale_input</code>: <code>1.0</code> <p>Upscale input by factor. This augments the input data from e.g. 100 Hz to 50 Hz (factor: <code>2</code>). Can be useful for high-frequency microseismic events.</p> <code>phase_map</code> <p>Phase mapping from SeisBench PhaseNet to Lassie phases.</p> <code>weights</code> <p>Weights for each phase.</p> JSON for SeisBench<pre><code>{\n  \"image\": \"SeisBench\",\n  \"model\": \"PhaseNet\",\n  \"pretrained\": \"original\",\n  \"window_overlap_samples\": 1500,\n  \"torch_use_cuda\": true,\n  \"torch_cpu_threads\": 4,\n  \"batch_size\": 128,\n  \"stack_method\": \"avg\",\n  \"rescale_input\": 1.0,\n  \"phase_map\": {\n    \"P\": \"constant:P\",\n    \"S\": \"constant:S\"\n  },\n  \"weights\": {\n    \"P\": 1.0,\n    \"S\": 1.0\n  }\n}\n</code></pre>"},{"location":"components/octree/","title":"Octree","text":"<p>A 3D space is searched for sources of seismic energy. Qseek created an octree structure which is iteratively refined when energy is detected, to focus on the source' location. This speeds up the search and improves the resolution of the localisations.</p> <p></p> <p>Surface projection of the refined octree focusing on the seismic source region. In this example four levels of refinement are can be seen, refining the 3D octree from the initial 4000 nodes to 8823 nodes.</p> <p></p>"},{"location":"components/octree/#exec-6--octree-module","title":"Octree Module","text":"Config OctreeJSON  <code>location</code> <p>The reference location of the octree.</p> <code>root_node_size</code>: <code>1000.0</code> <p>Initial size of the root octree node at level 0 in meters.</p> <code>n_levels</code>: <code>5</code> <p>Number of levels in the octree, this defines the final resolution of the detection. Default is 1.</p> <code>east_bounds</code> <p>East bounds of the octree in meters.</p> <code>north_bounds</code> <p>North bounds of the octree in meters.</p> <code>depth_bounds</code> <p>Depth bounds of the octree in meters.</p> JSON for Octree<pre><code>{\n  \"location\": {\n    \"lat\": 0.0,\n    \"lon\": 0.0,\n    \"east_shift\": 0.0,\n    \"north_shift\": 0.0,\n    \"elevation\": 0.0,\n    \"depth\": 0.0\n  },\n  \"root_node_size\": 1000.0,\n  \"n_levels\": 5,\n  \"east_bounds\": [\n    -10000.0,\n    10000.0\n  ],\n  \"north_bounds\": [\n    -10000.0,\n    10000.0\n  ],\n  \"depth_bounds\": [\n    0.0,\n    20000.0\n  ]\n}\n</code></pre>"},{"location":"components/ray_tracer/","title":"Ray Tracers","text":"<p>The calculation of seismic travel times is a cornerstone for the migration and stacking approach. Qseek supports different ray tracers for travel time calculation, which can be adapted for different geological settings.</p>"},{"location":"components/ray_tracer/#constant-velocity","title":"Constant Velocity","text":"<p>The constant velocity models is trivial and follows:</p> \\[ t_{P} = \\frac{d}{v_P} \\] <p>This module is used for simple use cases and cross-referencing testing.</p> <p></p>"},{"location":"components/ray_tracer/#exec-7--constantvelocitytracer-module","title":"ConstantVelocityTracer Module","text":"<p>Travel time tracer with a constant velocity.</p> Config ConstantVelocityTracerJSON  <code>phase</code>: <code>constant:P</code> <p>Name of the phase.</p> <code>velocity</code>: <code>5000.0</code> <p>Constant velocity of the phase in m/s.</p> JSON for ConstantVelocityTracer<pre><code>{\n  \"tracer\": \"ConstantVelocityTracer\",\n  \"phase\": \"constant:P\",\n  \"velocity\": 5000.0\n}\n</code></pre>"},{"location":"components/ray_tracer/#1d-layered-model","title":"1D Layered Model","text":"<p>Calculation of travel times in 1D layered media is based on the Pyrocko Cake ray tracer.</p> <p> Pyrocko Cake 1D ray tracer for travel time calculation in 1D layered media</p> <p></p>"},{"location":"components/ray_tracer/#exec-8--caketracer-module","title":"CakeTracer Module","text":"<p>Travel time ray tracer for 1D layered earth models.</p> Config CakeTracerJSON  <code>phases</code> <p>Dictionary of phases and timings to calculate.</p> <code>earthmodel</code> <p>Earth model to calculate travel times for.</p> <code>trim_earth_model_depth</code>: <code>True</code> <p>Trim earth model to max depth of the octree.</p> <code>lut_cache_size</code> <p>Size of the LUT cache. Default is <code>2G</code>.</p> JSON for CakeTracer<pre><code>{\n  \"tracer\": \"CakeTracer\",\n  \"phases\": {\n    \"cake:P\": {\n      \"definition\": \"P,p\"\n    },\n    \"cake:S\": {\n      \"definition\": \"S,s\"\n    }\n  },\n  \"earthmodel\": {\n    \"filename\": \"/home/marius/.cache/qseek/velocity_models/default.nd\",\n    \"format\": \"nd\",\n    \"crust2_profile\": \"\"\n  },\n  \"trim_earth_model_depth\": true,\n  \"lut_cache_size\": 2147483648\n}\n</code></pre>"},{"location":"components/ray_tracer/#3d-fast-marching","title":"3D Fast Marching","text":"<p>We implement the fast marching method for calculating first arrivals of waves in 3D volumes. Currently three different 3D velocity models are supported:</p> <ul> <li> Import NonLinLoc 3D velocity model</li> <li> 1D layered model \ud83e\udd5e</li> <li> Constant velocity, mainly for testing purposes \ud83e\udd7c</li> </ul> <p> Conceptual 2D visualisation for seismic traveltimes calculation in heterogenous media using the fast-marching method for the Eikonal solution is presented. Traveltimes from the receiving station at the surface (indicated by a yellow triangle) towards the subsurface grid are calculated, resulting in station-specifig traveltimes for all potential source locations simultaneously.</p> <p></p>"},{"location":"components/ray_tracer/#exec-9--fastmarchingtracer-module","title":"FastMarchingTracer Module","text":"<p>Travel time ray tracer using the Fast Marching Method for 3D earth models.</p> Config FastMarchingTracerJSON  <code>interpolation_method</code>: <code>nearest | linear | cubic</code> <p>Interpolation method for travel times in the volume. Choose from <code>nearest</code>, <code>linear</code> or <code>cubic</code>.</p> <code>nthreads</code>: <code>0</code> <p>Number of threads to use for travel time. If set to <code>0</code>, <code>cpu_count*2</code> will be used.</p> <code>lut_cache_size</code> <p>Size of the LUT cache. Default is <code>2G</code>.</p> <code>velocity_model</code> <p>Velocity model for the ray tracer.</p> <code>implementation</code>: <code>pyrocko | scikit-fmm</code> <p>Implementation of the Fast Marching Method. Pyrocko only supports first-order FMM for now.</p> JSON for FastMarchingTracer<pre><code>{\n  \"tracer\": \"FastMarchingRayTracer\",\n  \"phase\": \"fm:P\",\n  \"interpolation_method\": \"cubic\",\n  \"nthreads\": 0,\n  \"lut_cache_size\": 2147483648,\n  \"velocity_model\": {\n    \"model\": \"Constant3DVelocityModel\",\n    \"grid_spacing\": \"octree\",\n    \"velocity\": 5000.0\n  },\n  \"implementation\": \"scikit-fmm\"\n}\n</code></pre>"},{"location":"components/ray_tracer/#visualizing-3d-models","title":"Visualizing 3D Models","text":"<p>For quality check, all 3D velocity models are exported to <code>vtk/</code> folder as <code>.vti</code> files. Use ParaView to inspect and explore the velocity models.</p> <p> Seismic velocity model of the Utah FORGE testbed site, visualized in ParaView.</p>"},{"location":"components/seismic_data/","title":"Seismic Data","text":""},{"location":"components/seismic_data/#waveform-data","title":"Waveform Data","text":"<p>The seismic can be delivered in MiniSeed or any other format compatible with Pyrocko. Qseek utilizes the Pyrocko Squirrel for fast and asynchronous data access.</p> <p>To prepare your data for EQ detection and localisation, organize it in a MiniSeed file or an SDS structure.</p> <p></p>"},{"location":"components/seismic_data/#exec-10--pyrockosquirrel-module","title":"PyrockoSquirrel Module","text":"<p>Waveform provider using Pyrocko's Squirrel.</p> Config PyrockoSquirrelJSON  <code>environment</code> <p>Path to a Squirrel environment.</p> <code>persistent</code> <p>Name of the persistent collection for faster loading.</p> <code>waveform_dirs</code> <p>List of directories holding the waveform files.</p> <code>start_time</code> <p>Start time for the search in ISO8601.</p> <code>end_time</code> <p>End time for the search in ISO8601.</p> <code>channel_selector</code> <p>Channel selector for waveforms, e.g. <code>['HH', 'EN']</code>.</p> <code>n_threads</code>: <code>8</code> <p>Number of threads for loading waveforms.</p> JSON for PyrockoSquirrel<pre><code>{\n  \"provider\": \"PyrockoSquirrel\",\n  \"environment\": null,\n  \"persistent\": \"docs\",\n  \"waveform_dirs\": [],\n  \"start_time\": null,\n  \"end_time\": null,\n  \"channel_selector\": null,\n  \"n_threads\": 8\n}\n</code></pre>"},{"location":"components/seismic_data/#meta-data","title":"Meta Data","text":"<p>Meta data is required primarily for station locations and codes.</p> <p>Supported data formats are:</p> <ul> <li> StationXML</li> <li> Pyrocko Station YAML</li> </ul> <p>Metadata does not need to include response information for pure detection and localisation. If local magnitudes M<sub>L</sub> are extracted, response information is required.</p> <p></p>"},{"location":"components/seismic_data/#exec-11--stations-module","title":"Stations Module","text":"Config StationsJSON  <code>pyrocko_station_yamls</code> <p>List of Pyrocko station YAML files.</p> <code>station_xmls</code> <p>List of StationXML files or directories containing StationXML (.xml) files.</p> <code>blacklist</code> <p>Blacklist stations and exclude from detecion. Format is <code>['NET.STA.LOC', ...]</code>.</p> JSON for Stations<pre><code>{\n  \"pyrocko_station_yamls\": [],\n  \"station_xmls\": [],\n  \"blacklist\": [],\n  \"stations\": []\n}\n</code></pre>"},{"location":"components/station_corrections/","title":"Station Corrections","text":"<p>Station corrections can be extract from previous runs to refine the localisation accuracy. The corrections can also help to improve the semblance find more events in a dataset.</p>"},{"location":"components/station_corrections/#station-specific-corrections","title":"Station Specific Corrections","text":"<p> Statistics of station delay times.</p> <p></p>"},{"location":"components/station_corrections/#exec-12--stationcorrections-module","title":"StationCorrections Module","text":"Config StationCorrectionsJSON  <code>import_rundir</code> <p>Path to rundir, to extract the station corrections from.</p> <code>plot_corrections</code>: <code>False</code> <p>Plot the station corrections statistics.</p> <code>statistic</code>: <code>median | average</code> <p>Arithmetic measure for the traveltime delays. Choose from <code>median</code> and <code>average</code>.</p> <code>weighting</code>: <code>none | confidence | semblance | add-confidence-semblance | mul-confidence-semblance</code> <p>Weighting of the traveltime delays. Choose from <code>none</code>, <code>confidence</code>, <code>semblance</code>, <code>add-confidence-semblance</code> and <code>mul-confidence-semblance</code>.</p> <code>min_num_picks</code>: <code>50</code> <p>Minimum number of picks at a station required to calculate station corrections.</p> JSON for StationCorrections<pre><code>{\n  \"corrections\": \"StationCorrections\",\n  \"import_rundir\": \".\",\n  \"plot_corrections\": false,\n  \"statistic\": \"median\",\n  \"weighting\": \"mul-confidence-semblance\",\n  \"min_num_picks\": 50\n}\n</code></pre>"},{"location":"components/station_corrections/#source-specific-corrections","title":"Source Specific Corrections","text":"<p> Delay volume for a selected stations.</p> <p></p>"},{"location":"components/station_corrections/#exec-13--sourcespecificstationcorrections-module","title":"SourceSpecificStationCorrections Module","text":"<p>Source specific station travel time corrections.</p> Config SourceSpecificStationCorrectionsJSON  <code>import_rundir</code> <p>Path to rundir, to extract the station corrections from.</p> <code>statistic</code>: <code>median | average</code> <p>Arithmetic measure for the traveltime delays. Choose from <code>median</code> and <code>average</code>.</p> <code>weighting</code>: <code>none | confidence | semblance | add-confidence-semblance | mul-confidence-semblance</code> <p>Weighting of the traveltime delays. Choose from <code>none</code>, <code>confidence</code>, <code>semblance</code>, <code>add-confidence-semblance</code> and <code>mul-confidence-semblance</code>.</p> <code>min_num_picks</code>: <code>-1</code> <p>Minimum number of picks required for each node to calculate station corrections. -1 takes all stations.</p> <code>octree_level</code>: <code>0</code> <p>The octree level to use for the station corrections.</p> <code>delay_interpolation_method</code>: <code>nearest | linear | cubic</code> <p>The interpolation method to use for interpolating delays between nodes.</p> <code>lut_cache_size</code> <p>Size of the LUT cache. Default is <code>2G</code>.</p> JSON for SourceSpecificStationCorrections<pre><code>{\n  \"corrections\": \"SourceSpecificStationCorrections\",\n  \"import_rundir\": \".\",\n  \"statistic\": \"average\",\n  \"weighting\": \"mul-confidence-semblance\",\n  \"min_num_picks\": -1,\n  \"octree_level\": 0,\n  \"delay_interpolation_method\": \"linear\",\n  \"lut_cache_size\": 2147483648\n}\n</code></pre>"}]}